/*因为有好几个reducer，所以需要引入conbine 将他们组合在一起*/import {combineReducers} from 'redux'import {    ERROR_MSG,    AUTH_SUCCESS,    RECEIVE_USER,    RESET_MSG,    RECEIVE_USER_LIST,    RECEIVE_MSG,    RECEIVE_CHAT_LIST,    MSG_READ} from "./action-type";import {getRedirectTo} from '../utils/index'/* 管理状态 - 看需要管理什么 code user msg 从后台传回来的数据一般都需要 管理起来    存储user信息        username        password        msg        这三个数据都会从后台返回然后存储状态，都需要在页面中显示* */const initUser = {    username:'', // 用户名    type:'',// 用户类型  jingyin/boss    msg:'', // 错误提示信息    redirectTo: '' // 需要自动重定向的路由路径}// reducer的作用，获取最新的信息通过dispathch传入的action 的数据进行更新//产生user状态的reducer -- 因为多个数据所以定义一个变量初始化状态    // 分发action之后处理 获取的信息更新页面的数据function user(state=initUser,action) {    switch (action.type){        case ERROR_MSG: //成功时data为user            // return action.data            return {...state, msg: action.data} // 先...旧的然后获取新的将旧的覆盖 注意两边用{}处理        case AUTH_SUCCESS: // 失败时data为msg            const {type,header} = action.data            // return action.data            return {...action.data, redirectTo:getRedirectTo(type,header)}        case RESET_MSG:            return {...initUser,msg:action.data}        case RECEIVE_USER:            //此时action.data的state包含多个 header/_id/username/info/salary.....            return action.data        default:            return state    }}const initUserList = []//重新定义一个reducer用来更新用户列表 是一个数组 function userList(state=initUserList,action) {    switch (action.type){        case RECEIVE_USER_LIST:            // console.log('action.type='+action.type)            // console.log('action.data='+action.data)            return action.data        default:            return state    } }const initChat = {    users:{}, // 所有用户信息的对象   属性名 userid 属性值是{username，header}    chatMsgs:[], // 当前用户的所有相关的msg的数组 所有的信息 [time,]    unReadCount:0 // 总的未读数量} //产生聊天状态的reducer function chat(state=initChat,action) {    switch (action.type) {        case RECEIVE_CHAT_LIST:  // data ：users chatMsgs            const {users,chatMsgs,userid} = action.data            return {                users,                chatMsgs,                // 这是所有的有关的消息  没分组                unReadCount:chatMsgs.reduce( (pretotal,msg)=>{                   return pretotal+(!msg.read && msg.to === userid?1:0)                },0)            }        case RECEIVE_MSG:            const {chatMsg} = action.data            return {                // 错误 state.users                users:state.users,                //在以前的内容的基础上添加一条新的内容                chatMsgs:[...state.chatMsgs,chatMsg],                unReadCount:state.unReadCount + (!chatMsg.read && chatMsg.to === action.data.userid?1:0)                //收到消息之后数量是以前的数量+现在收到的消息数量  然后进行判断            }        case MSG_READ:            const {from,to,count} = action.data            return {                //后台发送请求的时候不是已经更改状态了吗  那么在这里更改是什么意思？？？                users: state.users,                chatMsgs:state.chatMsgs.map( (msg)=>{                    if(msg.from === from&& msg.to===to && !msg.read){                        // 先...把以前的数据打开 然后                        // 以前的数据 都是false，然后把更改的数据放进去                        // 已经显示好的数据                        // 找到一些msg，将满足条件的信息遍历出来的信息列表 将read改为true                        // map不会改变原来的数据 ，foreach会改                        return {...msg,read:true}                    } else {                        return msg                    }                }),                unReadCount:state.unReadCount - count            // 以前的未读数量减去现在读取了的数量            }        default:           return state    } }// 将user暴露出去 user return 出来的是一个state的对象 ，state的内容不止是初始化的那些还有传过来的那些export default combineReducers({    user,    userList,    chat})//管理的状态是一个对象 （user）