/* n个action creator*  同步action*  异步action*       登录*       注册** */import io from 'socket.io-client'import {    ERROR_MSG,    AUTH_SUCCESS,    RECEIVE_USER,    RESET_MSG,    RECEIVE_USER_LIST,    RECEIVE_CHAT_LIST,    RECEIVE_MSG,    MSG_READ} from "./action-type";import {    reqRegister,    reqLogin,    reqUpdateUser,    reqUser,    reqUserList,    reqChatMsgList,    reqReadMsg} from "../api";/*每一个action都对应一个同步action*///授权成功的action  dispatch(action -- type)//  data 为发送请求回来的数据/ 错误信息const authSuccess = (user) => ({type:AUTH_SUCCESS,data:user})const errorMsg = (msg) => ({type:ERROR_MSG,data:msg})export const resetMsg = (msg) => ({type:RESET_MSG,data:msg})const receiveMsg = (user) => ({type:RECEIVE_USER,data:user})export const receiveUserList = (userList) => ({type:RECEIVE_USER_LIST,data:userList})//接收消息的同步消息列表 actionconst receiveChatList = ({users,chatMsgs,userid}) =>({type:RECEIVE_CHAT_LIST,data:{users,chatMsgs,userid}})// 接收一个消息的同步actionconst receiveOnlyMsg = (chatMsg,userid) => ({type:RECEIVE_MSG,data:{chatMsg,userid}})// 读取某个聊天消息的同步actionconst msgRead = ({from,to,count}) => ({type:MSG_READ,data:{from,to,count}})//将io封装成一个函数function initIO(dispatch,userid) {    /*    因为每次调用这个函数都会创建一个新的socket所以需要 单例对象 -- 单一的实例只有一个socket不会产生多个    单例对象：        创建对象之前：判断对象是否已经存在，只有不存在的时候才会去创建        创建对象之后：保存对象  保存在io身上    * */    if(!io.socket){        //连接服务器 得到与服务器连接的对象        io.socket = io('ws://localhost:4000')        //绑定监听事件 从 服务器接收信息        io.socket.on('receiveMsg',function (chatMsg) {            console.log('从服务器发来的信息--',chatMsg )            //判断只有当chatMsg是与当前用户相关的消息才会分发同步action保存            if(chatMsg.from === userid || chatMsg.to === userid){                //更新 最新发送的消息                dispatch(receiveOnlyMsg(chatMsg,userid))            }        })    }    //创建socket对象 绑定io对象}// 工具函数 异步获取消息列表数据async function getMsgList(dispatch,userid) {    initIO(dispatch,userid);    //异步ajax    const response = await reqChatMsgList()    const result = response.data    if(result.code === 0) {        const {users,chatMsgs} = result.data        dispatch(receiveChatList({users,chatMsgs,userid}))    }}export const sendMsgs = ({from,to,content}) => {    // 传对象过去  要不然只有值而没有key    return dispatch =>{        console.log('点击发送的消息',{from,to,content})        io.socket.emit('sendMsg',{from,to,content})    }}//读取消息的异步action更新状态export const readMsg = (from,to) =>{    return async dispatch=>{        const response = await reqReadMsg(from)        const result = response.data        if(result.code ===0){            const count = result.data // 后台返回的数据            dispatch (msgRead({count,from,to}))        }    }}//注册异步action okexport const register = (user) => {    /*    * user 传过来有 pwd pwd2 username type 不需要pwd2去后台请求    * */    const {username,password,password2,type} = user    //做表单的前台验证    if(!username){        return errorMsg("请输入用户名")    }else if(password !== password2) {        return errorMsg("两次密码输入不一致")    }    //表单输入合法 返回一个发ajax请求的异步action    //异步必须return 返回一个函数    return async dispatch => {        //发送注册的异步ajax请求 -- 异步的ajax请求        /*reqRegister(user).then(response =>{            return response.data        })*/        // 需要发送过去自己输入的信息        // ！！返回的是一个promise对象            // user 是发送到后台的数据需要自己填写 从输入的dispath的action中穿过来user的值然后传入到ajax的请求中去        const response = await reqRegister({password,username,type})        // 用acync 的方式直接获取response 用await之后 等这个函数调用完毕之后返回 数据        // await 意思是等promise对象结果返回出来 ，前提这个函数必须声明成async函数        const result = response.data        // result  -->  {code：0/1，data:{}/msg:“” }        if(result.code === 0 ){            //成功            getMsgList(dispatch,result.data._id)            //分发同步的action  -- 就需要action - type 了            dispatch(authSuccess(result.data))        }else {            //失败            //分发同步的action            dispatch(errorMsg(result.msg))        }    }}//登录异步action okexport const login = (user) => {    const {password,username} = user    //做表单的前台验证    if(!username){        return errorMsg("请输入用户名")    } else if(!password){        return errorMsg("请输入密码")    }    //异步必须return 返回一个函数    return async dispatch => {        //发送注册的异步ajax请求 -- 异步的ajax请求        /*reqRegister(user).then(response =>{            return response.data        })*/        // 需要发送过去自己输入的信息        // ！！返回的是一个promise对象        const response = await reqLogin(user)        // 用acync 的方式直接获取response 用await之后 等这个函数调用完毕之后返回 数据        // await 意思是等promise对象结果返回出来 ，前提这个函数必须声明成async函数        const result = response.data        // result  -->  {code：0/1，data:{}/msg:“” }        if(result.code ===0 ){            //成功            getMsgList(dispatch,result.data._id)            //分发同步的action  -- 就需要action - type 了            dispatch(authSuccess(result.data))        }else {            //失败            //分发同步的action            dispatch(errorMsg(result.msg))        }    }}// 更新用户异步的actionexport const updateUser = (user) => {    // 传入用户输入的信息 进行ajax请求 到后台 ，然后返回一个新的信息包含一堆数据的    return async dispatch => {        const response  = await reqUpdateUser(user)        const result = response.data        //获取到后台传来的信息之后 分发同步action 更新状态        //返回 三个数据  code msg data        if(result.code === 1) {            // == 1 说明分发重置action            dispatch(resetMsg(result.msg))        }else if(result.code === 0){            dispatch(receiveMsg(result.data))        }    }}// 获取用户异步actionexport const getUser = () =>{    return async  dispatch => {        const response = await reqUser()        const result = response.data        if(result.code === 0) {            //自动登录的话            getMsgList(dispatch,result.data._id)            dispatch(receiveMsg(result.data))        }else {            dispatch(resetMsg(result.msg))        }    }}export const getUserList = (type) => {    return async dispatch =>{        const response = await reqUserList(type)        const result = response.data        // console.log('action中的code='+result.code)        if(result.code === 0){            // console.log('action中的result='+result.data)            dispatch(receiveUserList(result.data))        }else {            dispatch(receiveUserList(result.msg))        }    }}//异步发送消息的异步action//一旦登录就获取消息列表    //注册成功    //登录成功    //自动登录成功    // 需要传入dispatch分发action